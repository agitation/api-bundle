services:

# configuration for the pluggable services and their registration listener factories

    # ENDPOINTS

    agit.endpoint.register:
        private: true
        class: CacheAwareServiceListener
        factory_service:  agit.pluggable.cache.listener.factory
        factory_method:   create
        arguments: [ agit.api.endpoint ]
        tags: [{ name: kernel.event_listener, event: agit.pluggable, method: onRegistration }]

    agit.api.endpoint.listener.factory:
        arguments: [ @annotation_reader, @agit.core.classcollector, endpoint, \Agit\ApiBundle\Api\Endpoint\AbstractEndpoint ]
        class: Agit\ApiBundle\EventListener\ApiPluginListenerFactory

    # OBJECTS

    agit.object.register:
        private: true
        class: CacheAwareServiceListener
        factory_service:  agit.pluggable.cache.listener.factory
        factory_method:   create
        arguments: [ agit.api.object ]
        tags: [{ name: kernel.event_listener, event: agit.pluggable, method: onRegistration }]

    agit.api.object.listener.factory:
        arguments: [ @annotation_reader, @agit.core.classcollector, object, \Agit\ApiBundle\Api\Object\AbstractObject ]
        class: Agit\ApiBundle\EventListener\ApiPluginListenerFactory

    # FORMATTERS

    agit.formatter.register:
        private: true
        class: CacheAwareServiceListener
        factory_service:  agit.pluggable.cache.listener.factory
        factory_method:   create
        arguments: [ agit.api.formatter ]
        tags: [{ name: kernel.event_listener, event: agit.pluggable, method: onRegistration }]

    agit.api.formatter.listener.factory:
        arguments: [@annotation_reader, @agit.core.classcollector, formatter, \Agit\ApiBundle\Api\Formatter\AbstractFormatter]
        class: Agit\ApiBundle\EventListener\ApiPluginListenerFactory
